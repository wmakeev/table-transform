# TODO

## Основное

- [ ] Может быть стоит объединять одноименные колонки в массив при вызове select?

- [ ] Ошибка проверки заголовка (напр. в select) внутри fork не на момент страта,
      а в процессе обработки данных (Подумать можно ли исправить. Видимо ленивая
      инициализация трансформаций.)

- [ ] Нужно строить граф трансформаций. Важно для отладки. Учитывать compose?
      Возможно при compose задавать label для группы.

- [ ] Реализовать базовый класс для трансформации (уже есть ряд общих методов).

- [ ] Для всех трансформаций нужно написать тесты с наличием колонок-массивов

## Трансформации

- [ ] Нужен `assert` который бы генерировал динамически формируемое сообщение.
      Например сообщение об ошибке из HTTP запроса.

- [ ] Добавить `debounce` и возможно `rateLimit`

- [ ] Добавить `column.assertTypes({ columnTypes: { 'some': { type: 'String', optional: true } } })`

- [ ] Добавить `tf.row.foldToRecord({ resultColumn: 'item' })` - сворачивает строку в объект

- [ ] #hyssd6e В `column` / `columns` передавать селектор колонки

  ```js
  tf.column.transform({
    columns: column('name')
  })
  ```

  ```js
  tf.column.transform({
    columns: column({ name: 'name', index: 1 })
  })
  ```

  ```js
  tf.column.transform({
    columns: column.name('name').index(1)
  })
  ```

  ```js
  tf.column.transform({
    columns: column.all()
  })
  ```

  Селектор может выбирать сразу несколько колонок. Если выбраны несколько колонок,
  то трансформация сразу проходит по всем выбранным.

  Совместима ли данная логика со всеми трансформациями?

  Нужно занести всё в сводную таблицу для согласования.

- [ ] Убрать из `tf.column.add` значение по умолчанию. Это вызывает неоднозначность
      в случаях когда колонка уже создана и заполнение не будет происходить.
      Если нужно заполнить колонку, то это надо сделать явно. Либо создать
      композитную операцию.

- [ ] Нужны трансформации по всем колонкам (возможно реализовать с новым селектором колонок).
      Например, для случая когда нужно очистить все колонки кроме некоторых если
      выполняется некоторое условие. Заполнить колонку при условии (выражение
      не сложно добавить для других трансформаций вроде `fill`).

## Оптимизации

- [ ] Идея: Пометить каждую трансформацию как mutable и immutable. Тогда операции
      fork вида смогут оптимизировать работу отправляя в immutable ветку данные без
      создания копии, что даст оптимизацию по памяти.

- [ ] Подумать можно ли ввести более оптимальный метод для следующей трансформации:

  ```js
  tf.splitIn({
    keyColumns: ['id'],
    transformConfig: {
      transforms: [tf.take({ count: 1 })]
    }
  })
  ```

## Композитные методы

- [ ] Нужна возможность создавать кастомные трансформации через комбинирование
      прочих встроенных. Конфигурация параметров и далее использование этих параметров
      при создании дорожки. Эта методика подходит не только для сложных трансформаций
      но и для создания расширения встроенных таких как `putProbeMany` и пр.

- [ ] Добавить `Column:SortBy` (композитный с промежуточной колонкой)

- [ ] Добавить композитный метод `column.explodeAndRename` (часто нужно
      переименовать после применения explode)

- [ ] Добавить параметр `removeSourceColumn: boolean` в `column.unfold` - частый
      случай. Или реализовать через композитную трансформацию.
